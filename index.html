<!DOCTYPE HTML>
<html>
<head>

  <title>Nifty!</title>

  <style>
  body {
    background: none;
  }
  </style>

</head>

<body>

<script>

const plib = require('path');
const Fuse = require('fuse.js');

let onAppReshow = null;
let hideApp;
{
  const win = nw.Window.get();
  hideApp = () => win.hide();
  nw.App.on('open', () => {
    // This event fires when the user tries to start the app but
    // it's already open in an existing process
    win.show();
    win.setPosition('center');
    win.focus();
    onAppReshow && onAppReshow();
  });
}

document.addEventListener('DOMContentLoaded', () => {
  try {
    main();
  } catch (e) {
    console.error(e.stack);
    nw.App.quit();
  }
});

function main() {
  const argv = nw.App.argv;
  if (argv.length !== 2)
    throw Error('Expected exactly 1 argument, a path to a javascript file');
  const { default: client } = require(plib.resolve(process.env.PWD, argv[1]))

  const win = nw.Window.get();
  win.setPosition('center');
  initRender(client);
}

function initRender(client) {

  const $body = document.body;

  const $main = document.createElement('main');
  $body.append($main);

  const $search = document.createElement('input');
  $main.append($search)
  $search.id = 'search';
  $search.type = 'text';
  $search.focus();

  const $items = document.createElement('div');
  $items.id = 'items';
  $main.append($items);

  const initState = {
    client,
    selectIndex: 0,
    query: '',
    $elems: { $body, $main, $search, $items },
  };
  render(initState);

}

function render(state) {

  const resultItems = callClient(state);

  const $items = document.createElement('div');
  $items.id = 'items';

  state.$elems.$items.replaceWith($items);
  state.$elems.$items = $items;

  for (const [item, index] of enumerate(resultItems)) {
    const $item = item.render({ isSelected: index === state.selectIndex });
    $items.append($item);
  }

  // --

  const target = trackListeners(state.$elems.$search);
  const purgeAndRender = state => { target.clearEventListeners(); render(state); };
  target.addEventListener('keydown', ev => onKeyDown(ev, purgeAndRender));
  target.addEventListener('input', ev => onInput(ev, purgeAndRender));

  function onKeyDown(ev, render) {

    if (ev.key === 'ArrowDown' || ev.key === 'ArrowUp') {
      ev.preventDefault();
      if (state.selectIndex === null) {
        state.selectIndex =
          mod(ev.key === 'ArrowDown' ? 0 : -1, resultItems.length);
      } else {
        const delta = ev.key === 'ArrowDown' ? 1 : -1;
        state.selectIndex = mod(state.selectIndex + delta, resultItems.length);
      }
      render(state);
    }

    else if (ev.key === 'Enter') {
      if (state.selectIndex === null) return;
      const selected = resultItems[state.selectIndex];
      if (!selected) return;
      hideApp();  // in case exec() does something like take a screenshot
      console.log(`Selected: ${selected.displayText}`);
      selected.exec();
      softCloseApp();
    }

    else if (ev.key === 'Escape') {
      softCloseApp();
    }

    // Prefer a soft-close over a quit because quick startup time is crucial
    // for an app like this
    function softCloseApp() {
      hideApp();
      state.$elems.$search.value = '';
      state.query = '';
      state.selectIndex = 0;
      render(state);
      onAppReshow = () => {
        state.$elems.$search.focus();
      };
    }

  }

  function onInput(ev, render) {
    state.query = state.$elems.$search.value;
    state.selectIndex = 0;
    render(state);
  }

}

// Client library object
const lib = {

  sort(items, query) {
    const sticky = items.filter(item => item.isSticky);
    const nonsticky = items.filter(item => !item.isSticky);

    const stickySorted = fuzzySort(sticky, 'searchText', query);
    const nonstickySorted = fuzzySort(nonsticky, 'searchText', query);

    return [].concat(stickySorted, nonstickySorted);
  },

  exec(str) {
    const proc = require('child_process');
    const child = proc.spawn(
      '/usr/bin/env',
      ['bash', '-c', str],
      {
        detached: true,
        stdio: ['ignore', 'inherit', 'inherit'],
      }
    );
    child.unref();
  },

  mkSimple({
    text,
    exec,
    icon,
    isSticky,
  }) {
    return lib.mkItem({
      displayText: text,
      searchText: text,
      exec,
      icon,
      isSticky,
    })
  },

  mkItem({
    displayText,
    searchText,
    exec,
    isSticky,
    icon
  }) {
    return {
      displayText,
      searchText,
      exec: exec || (() => {}),
      isSticky: isSticky || false,
      render({ isSelected }) {
        const $item = document.createElement('div');
        $item.classList.add('item');
        if (isSelected) $item.classList.add('selected');

        if (icon !== null && icon !== undefined) {
          const $icon = document.createElement('img');
          $item.append($icon);
          $icon.classList.add('item-icon');
          const blankImg = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
          $icon.src = icon ?? blankImg;
        }

        const $text = document.createElement('span');
        $item.append($text);
        $text.classList.add('item-text');
        if (displayText.trim() !== '')
          $text.innerText = displayText;
        else
          $text.innerHTML = '&nbsp;';

        return $item;
      },
    };
  },

}

function callClient(state) {
  return state.client(lib, state.query);
}

function * enumerate(xs) {
  let i = 0;
  for (const x of xs) {
    yield [x, i];
    i++;
  }
}

function mod(n, k) {
  return ((n % k) + k) % k;
}

function fuzzySort(items, key, query) {

  // sort
  const fuse = new Fuse(items, {
    keys: [key],
    minMatchCharLength: 0,
  });
  let result = fuse.search(query);
  result = result.map(el => el.item);

  // re-add removed items
  const keys = new Set(result.map(item => item[key]));
  for (const item of items) {
    if (!keys.has(item[key]))
      result.push(item);
  }

  return result;

}

function trackListeners($el) {
  const bound = [];
  return {
    addEventListener(evName, listener) {
      $el.addEventListener(evName, listener);
      bound.push([evName, listener]);
    },
    clearEventListeners() {
      for (const [evName, listener] of bound)
        $el.removeEventListener(evName, listener);
    },
  };
}

</script>

<style>

@import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@300&display=swap');

:root {
  --color-prim: #c06;
  --color-grey: lightgrey;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
}

main {
  background: white;
  box-shadow: 0 0 8px -4px rgba(20, 20, 20, .5);
  border-radius: 3px;
  border: 1px solid var(--color-prim);
  padding: 0.75em 1em;

  margin: 15px;
  max-height: calc(100vh - 30px);

  display: flex;
  flex-direction: column;
}

#search {
  width: 100%;
  font-size: 20px;
  padding: 0.5em 1em;
  border: 1px solid var(--color-grey);
  border-radius: 3px;
  font-family: 'Open Sans', sans-serif;
}

#search:focus {
  outline: none;
  border-color: var(--color-prim);
}

#items {
  display: flex;
  flex-direction: column;
  gap: 2px;
  overflow-y: auto;
  flex: 1;
}

#items:not(:empty) {
  margin-top: 10px;
}

.item {
  width: 100%;
  padding: 0.35em 0.7em;
  display: inline-flex;
  align-items: center;
  justify-content: left;
  font-size: 20px;
}

.item.selected {
  background-color: rgba(0, 0, 0, 0.05);
  border-radius: 4px;
}

.item-icon {
  height: 1.5em;
  width: 1.5em;
  margin-right: 20px;
}

.item-text {
  font-family: 'Open Sans', sans-serif;
}

</style>

</body>
</html>
